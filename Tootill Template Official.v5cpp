{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\n\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  int systemTime = Brain.Timer.systemHighResolution();\n  double batteryCurrent = Brain.Battery.current();\n  double batteryVoltage = Brain.Battery.voltage(voltageUnits::mV);\n\n  // Combine these values into a single integer\n  int seed = int(batteryVoltage + batteryCurrent * 100) + systemTime;\n\n  // Set the seed\n  srand(seed);\n}\n\n\n\nvoid vexcodeInit() {\n\n  //Initializing random seed.\n  initializeRandomSeed(); \n}\n\n\n// Helper to make playing sounds from the V5 in VEXcode easier and\n// keeps the code cleaner by making it clear what is happening.\nvoid playVexcodeSound(const char *soundName) {\n  printf(\"VEXPlaySound:%s\\n\", soundName);\n  wait(5, msec);\n}\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n// ----------------------------------------------------------------------------\n//                                                                            \n//    Project:                                               \n//    Author:\n//    Created:\n//    Configuration:        \n//                                                                            \n// ----------------------------------------------------------------------------\n\n// Include the V5 Library\n#include \"vex.h\"\n#include <cmath>\n#include <iostream>\n#include <vector>\n\nusing namespace vex;\n\n// Example motor definitions (Change these)\nmotor left1 = motor(PORT4, true);\nmotor left2 = motor(PORT1, true);\nmotor left3 = motor(PORT6, false);\n\nmotor right1 = motor(PORT2, false);\nmotor right2 = motor(PORT5, false);\nmotor right3 = motor(PORT3, true);\n\nrotation linearSensor = rotation(PORT16, false);\n\n\nmotor_group leftDrive = motor_group(left1, left2, left3);  // Front, Middle, Back Left\nmotor_group rightDrive = motor_group(right1, right2, right3); // Front, Middle, Back Right\n\n// Define inertial sensor\ninertial imu = inertial(PORT12);\n\n\n// Code for the Drive Curve\ndouble turningCurve = 5;\n bool turningRed = false;\n\n double forwardCurve = 5;\n bool forwardRed = true;\n\n int curveJoystick(bool red, int input, double t) {\n   int val = 0;\n   if(red){\n   val = (std::exp(-t/10)+std::exp((std::abs(input)-100)/10)*(1-std::exp(-t/10))) * input;   \n   }else{\n     //blue\n     val = std::exp(((std::abs(input)-100)*t)/1000) * input;\n   }\n   return val;\n }\n\n distanceUnits units = inches;\n\n// PID constants for Driving Forwards/Backwards (Change These When tuning)\ndouble kP = 10.0; // Proportional constant Speed of Response\ndouble kI = 0.0; // Integral constant Elimination of Steady-State Error\ndouble kD = 0.1; // Derivative constant Dampening of the Response\n\n\n// Wheel variables\ndouble wheelDiameter = 3.25; // Diameter of the driven wheel\ndouble gearRatio = 4.0/3.0; // Define your gear ratio here (e.g., 2.0 for 2:1 reduction)\ndouble encoderTicks = 300; // The Amount of Ticks per revolution the motor encoder has\n\nconst double trackingWheelDiameter = 2.75; // Diameter of the tracking wheel\nconst double trackingWheelCircumference = trackingWheelDiameter * M_PI;\nconst double rotationSensorTicksPerRevolution = 360.0; // For a VEX Rotation Sensor\n\n// PID constants for Turning Left/Right\ndouble turn_kP = 0.5; // Proportional constant\ndouble turn_kI = 0.1; // Integral constant\ndouble turn_kD = 0.1; // Derivative constant\n\n\n// PID variables for Driving Forwards/Backwards (DO NOT CHANGE)\ndouble error;\ndouble integral;\ndouble derivative;\ndouble previousError;\n\n// PID variables for Turning Left/Right (DO NOT CHANGE)\ndouble turn_error;\ndouble turn_integral;\ndouble turn_derivative;\ndouble turn_previousError;\n\n// Function to set drive motor velocities using motor groups\nvoid setDriveMotors(double leftVelocity, double rightVelocity) {\n  leftDrive.setVelocity(leftVelocity, velocityUnits::pct);\n  rightDrive.setVelocity(rightVelocity, velocityUnits::pct);\n}\n\n// Helper function to get distance from the rotation sensor\ndouble getTrackingWheelDistance() {\n  double currentRotation = linearSensor.position(degrees);\n  double revolutions = currentRotation / rotationSensorTicksPerRevolution;\n  double distanceTraveled = revolutions * trackingWheelCircumference;\n  return distanceTraveled;\n}\n\n// Function to move the robot forward a specified distance using PID and track actual distance\nvoid move_chassis(int direction, double targetDistance, int maxSpeed) {\n  // Reset rotation sensor\n  linearSensor.setPosition(0, degrees);\n\n  // Initialize PID variables\n  error = targetDistance - getTrackingWheelDistance();\n  integral = 0;\n  derivative = 0;\n  previousError = error;\n\n  // Loop until the robot reaches the target\n  while (fabs(error) > 0.01 || fabs(error) < -0.01) { // Adjust tolerance as needed\n    wait(10, msec);\n    // Debugging Code\n    Brain.Screen.setFillColor(black);\n    Brain.Screen.setPenColor(white);\n    Brain.Screen.clearLine(3);\n    Brain.Screen.setCursor(3, 1);\n    Brain.Screen.print(\"Target: %.2f\", targetDistance);\n    Brain.Screen.clearLine(4);\n    Brain.Screen.setCursor(4, 1);\n    Brain.Screen.print(\"Traveled: %.2f\", getTrackingWheelDistance());\n\n\n    // Calculate PID output\n    integral += error;\n    derivative = (error - previousError)/10;\n    double output = (kP * error) + (kI * integral) + (kD * derivative);\n\n    Brain.Screen.clearLine(6);\n    Brain.Screen.setCursor(6, 1);\n    Brain.Screen.print(\"PID Output: %.2f\", output);\n\n    // Limit output\n    if (output > maxSpeed) output = maxSpeed;\n    else if (output < -maxSpeed) output = -maxSpeed;\n\n    // Set motor velocities\n    setDriveMotors(output, output);\n    if(direction == 0){\n      leftDrive.spin(fwd);\n      rightDrive.spin(fwd);\n    }\n    else if(direction == 1){\n      leftDrive.spin(reverse);\n      rightDrive.spin(reverse);\n    }\n\n    // Update PID variables\n    previousError = error;\n    error = targetDistance - getTrackingWheelDistance();\n\n    // Calculate and display actual distance traveled (optional)\n    double averagePositionTicks = (((leftDrive.position(degrees) / 360.0) * encoderTicks) + ((rightDrive.position(degrees) / 360.0) * encoderTicks)) / 2.0;\n    double actualDistanceTraveled = (averagePositionTicks / encoderTicks) * (wheelDiameter * M_PI) / gearRatio;\n    Brain.Screen.clearLine(1);\n    Brain.Screen.print(\"Traveled: %.2f inches\", actualDistanceTraveled);\n  }\n\n  // Stop motors\n  setDriveMotors(0, 0);\n\n/*\n  // Final display of actual distance traveled\n  double finalAveragePosition = (leftDrive.position(degrees) + rightDrive.position(degrees)) / 2;\n  double finalActualDistanceTraveled = (finalAveragePosition / 360.0) * (3.25 * 3.41);\n  Brain.Screen.clearLine(1);\n  Brain.Screen.print(\"Traveled: %.2f inches\", finalActualDistanceTraveled);\n  Brain.Screen.newLine();\n  // std::cout << \"Final Traveled: \" << finalActualDistanceTraveled << \" inches\" << std::endl;\n  */\n}\n\n// Function to turn the robot a specified angle using PID and track actual angle\nvoid turn_chassis(double targetAngle) {\n  // Reset inertial sensor\n  imu.resetRotation();\n\n  // Initialize PID variables\n  turn_error = targetAngle - imu.rotation();\n  turn_integral = 0;\n  turn_derivative = 0;\n  turn_previousError = turn_error;\n\n  // Loop until the robot reaches the target angle\n  while (fabs(turn_error) > 1) { // Adjust tolerance as needed\n    // Calculate PID output\n    turn_integral += turn_error;\n    turn_derivative = turn_error - turn_previousError;\n    double output = turn_kP * turn_error + turn_kI * turn_integral + turn_kD * turn_derivative;\n\n    // Limit output\n    if (output > 100) output = 100;\n    else if (output < -100) output = -100;\n\n    // Set motor velocities (opposite directions for turning)\n    setDriveMotors(-output, output);\n    // Update PID variables\n    turn_previousError = turn_error;\n    turn_error = targetAngle - imu.rotation();\n\n    // Display actual angle (using IMU)\n    Brain.Screen.clearLine(2); // Clear the second line of the brain screen\n    Brain.Screen.print(\"Angle: %.2f degrees\", imu.rotation());\n    // std::cout << \"Angle: \" << imu.rotation() << \" degrees\" << std::endl;\n\n    // Delay\n    wait(20, msec);\n  }\n\n  // Stop motors\n  setDriveMotors(0, 0);\n\n  // Final display of actual angle\n  Brain.Screen.clearLine(2);\n  Brain.Screen.print(\"Angle: %.2f degrees\", imu.rotation());\n  // std::cout << \"Final Angle: \" << imu.rotation() << \" degrees\" << std::endl;\n}\n\n\n// Auton Selector code\nint AutonSelected = 0;\nint AutonMin = 0;\nint AutonMax = 1;\nbool autonLocked = false;\n\n// Array to store the names of the autonomous routines\nconst char* autonNames[] = {\n    \"Linear PID Test\",\n    \"Rotational PID Test\"\n};\n\n\n// Auton Selection GUI\nvoid drawGUI() {\n  // Draws 2 buttons to be used for selecting auto\n  Brain.Screen.clearScreen();\n  Brain.Screen.setFont(mono15);\n  Brain.Screen.setFillColor(black);\n  Brain.Screen.setPenColor(white);\n  Brain.Screen.setCursor(1, 1);\n  Brain.Screen.print(\"Select Auton Route\");\n  Brain.Screen.setCursor(2, 5);\n  Brain.Screen.print(\"Selected: %s\", autonNames[AutonSelected]);\n\n  // Previous Button\n  Brain.Screen.setFillColor(blue);\n  Brain.Screen.setPenColor(white);\n  Brain.Screen.drawRectangle(20, 80, 100, 40);\n  Brain.Screen.setPenColor(black);\n  Brain.Screen.setFont(mono30);\n  Brain.Screen.printAt(60, 109, \"<\");\n\n  // Next Button\n  Brain.Screen.setFillColor(blue);\n  Brain.Screen.setPenColor(white);\n  Brain.Screen.drawRectangle(140, 80, 100, 40);\n  Brain.Screen.setPenColor(black);\n  Brain.Screen.setFont(mono30);\n  Brain.Screen.printAt(185, 109, \">\");\n\n  // Lock In Button\n  Brain.Screen.setFillColor(green);\n  Brain.Screen.setPenColor(white);\n  Brain.Screen.drawRectangle(80, 140, 120, 40);\n  Brain.Screen.setPenColor(black);\n  Brain.Screen.setFont(mono20);\n  Brain.Screen.printAt(103, 165, \"Lock In\");\n\n  if (autonLocked) {\n    Brain.Screen.setFillColor(green);\n    Brain.Screen.drawCircle(300, 75, 20); // Indicate locked\n  } else {\n    Brain.Screen.setFillColor(red);\n    Brain.Screen.drawCircle(300, 75, 20); // Indicate not locked\n  }\n\n  Brain.Screen.setFillColor(black); // Reset fill color\n}\n\n// Auton Selection Code\nvoid selectAuton() {\n  int x = Brain.Screen.xPosition();\n  int y = Brain.Screen.yPosition();\n\n  if (!autonLocked) {\n    // Previous Button Pressed\n    if (x >= 20 && x <= 120 && y >= 80 && y <= 120) {\n      AutonSelected--;\n      if (AutonSelected < AutonMin) AutonSelected = AutonMax;\n      drawGUI();\n      wait(200, msec); // Debounce\n    }\n    // Next Button Pressed\n    else if (x >= 140 && x <= 240 && y >= 80 && y <= 120) {\n      AutonSelected++;\n      if (AutonSelected > AutonMax) AutonSelected = AutonMin;\n      drawGUI();\n      wait(200, msec); // Debounce\n    }\n    // Lock In Button Pressed\n    else if (x >= 80 && x <= 200 && y >= 140 && y <= 180) {\n      autonLocked = true;\n      drawGUI();\n      wait(500, msec); // Give time to see the lock\n    }\n  }\n}\n\n\nvoid preAutonomous(void) {\n  // actions to do when the program starts\n  Brain.Screen.clearScreen();\n  Brain.Screen.print(\"pre auton code\");\n\n  // Calibrate inertial sensor\n  imu.calibrate();\n\n  autonLocked = false;\n  drawGUI();\n  Brain.Screen.pressed(selectAuton);\n  while(!autonLocked) {\n    wait(10, msec);\n  }\n  Brain.Screen.setCursor(1, 200);\n  Brain.Screen.print(\"Auton %s Locked!\", autonNames[AutonSelected]);\n  wait(1, seconds);\n}\n\nvoid autonomous(void) {\n  Brain.Screen.clearScreen();\n  Brain.Screen.print(\"autonomous code\");\n\n  // place automonous code here\n  switch(AutonSelected) {\n\n  case 0:\n  // Testing linear movement\n  Brain.Screen.setFillColor(green);\n  move_chassis(0, 18, 50); // Move forward 18 inches\n  break;\n\n  case 1:\n  // Testing rotational movement\n  turn_chassis(90);\n  break;\n\n  }\n\n}\n\n\nvoid userControl(void) {\n  Brain.Screen.clearScreen();\n  // place driver control in this while loop\n  while (true) {\n    wait(20, msec);\n    // There are 2 choices for driving that are listed below\n\n    /* The Code Below is The Correct Configuration for Driving Arcade Drive\n    double turnVal = curveJoystick(turningRed, Controller1.Axis1.position(percent), turningCurve); //Get curvature according to settings [-100,100]\n    double forwardVal = curveJoystick(forwardRed, Controller1.Axis3.position(percent), forwardCurve); //Get curvature according to settings [-100,100]\n\n    double turnVolts = turnVolts = turnVal * 0.12; //Converts to Voltage\n    double forwardVolts = forwardVal * 0.12; //Converts to Voltage\n    \n    leftSide.spin(forwardVolts + turnVOlts, volt);\n    rightSide.spin(forwardVolts - turnVolts, volt);\n    */\n\n    /* The Code Below is The Correct Configuration for Driving Tank Drive\n    double turnVal = curveJoystick(turningRed, Controller1.Axis2.position(percent), turningCurve); //Get curvature according to settings [-100,100]\n    double forwardVal = curveJoystick(forwardRed, Controller1.Axis3.position(percent), forwardCurve); //Get curvature according to settings [-100,100]\n\n    double turnVolts = turnVolts = turnVal * 0.12; //Converts to Voltage\n    double forwardVolts = forwardVal * 0.12; //Converts to Voltage\n\n    leftSide.spin(forwardVolts + turnVOlts, volt);\n    rightSide.spin(forwardVolts + turnVolts, volt);\n    */\n\n\n\n  }\n}\n\nint main() {\n  // Initializing Robot Configuration. DO NOT REMOVE!\n  vexcodeInit();\n  // create competition instance\n  competition Competition;\n\n  // Set up callbacks for autonomous and driver control periods.\n    Competition.autonomous(autonomous);\n    Competition.drivercontrol(userControl);\n\n  // Run the pre-autonomous function.\n  preAutonomous();\n\n  // Prevent main from exiting with an infinite loop.\n  while (true) {\n    wait(100, msec);\n  }\n}","textLanguage":"cpp","robotConfig":[],"slot":5,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.1.0","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}